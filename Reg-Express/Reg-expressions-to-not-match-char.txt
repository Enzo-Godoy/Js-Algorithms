Introduction to the Regular Expression Challenges. 

Regular expressions are special strings that represent a search pattern. Also known as "regex" or "regexp", they help programmers match, search, and replace text. Regular expressions can appear cryptic beacuse a few character have special meaning. The goal is to combine the symbols and text into a pattern that matches what we want, but only what we want. This will cover the characters, a few shortcuts, and the common use for writing regular expressions. 


Using the test method. 
Regular expressions are used in programming languages to match parts of strings. We create patters to help to do that matching. 

If we want to find the word "the" in the string "The dog chased the cat", we
could use the following ecpresion : /the/

  //Notice that quote marks are not required within the regular expression. 

  The .test() method takes the regex, applies it to a string (wich is placed inside the parentheses), and returns true or false if our pattern finds something or not. 


  Example : 

  let testStr = "freeCodeCamp";
  let testRegex = /Code/; 
  testRegex.test(testStr); ---- > //Returns true


  Using regexes it's powerful to search single strings, but it's 
  limited to only one pattern. We can search for multiple patters using
  tje alternation or OR operator : '|' 

  This operator matches patterns either before or after it. We can also
  search for more than just two patters. 
  We can do this by adding more patters with more OR operator separating
  them, like /yes|no|maybe/ 

  regexes to do literal matches of strings. Sometimes we might want to also match case differences. 

  Case ( or sometimes letter) is the difference between uppercase letters and lowercase letters. 
  We can match both using ehat is called a flag. We can use it by appending
  it to the regex. 
  An example of using this flag is 

  /ignorecase/i  --- This regex math the strings 
  					 "ignorecase","igNoreCase", and "IgnoreCase"


  So far, we have only been cheking if a pattern exists or not within a string.
  We can also wxtract the actual matches we found with the .match() method.

  To use the .match() method, apply the methof on a string and pass in the
  regex inside parentheses.

  An Example : 

  --------------------------------------

  "Hello, World!".match(/Hello/); 
  // Returns ["Hello"]
  let ourStr = "Regular expressions"; 
  let ourRegex = /expressions/; 
  ourStr.match(ourRegec); 
  //Returns ["expressions"]

---------------------------------------

To searcj or extract a patter more than once, we can use the g flag 

let repeatRegex = /Repeat/ g ; 
testStr.match (repeatRegex); 
//Returns ["Repeat","Repeat","Repeat",];



Sometimes we won't (or don't need to) know exact characters in our patterns
Thinkinf of all words that match, say, a misspelling would take a long time, we can save time using the wildcard character: ('.')

The wildcard character '.' will match any one character. Also called 'dot'
and 'period'


Example 

let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./; 
humStr.match(huRegex);    //Returns ["hum"]
hugStr.match(huRegex);   // Returns ["hug"]





We learned how to match literal patterns (/literal/)  and wildcard
 character (/./)
 Those are the extremes of regular expressions, where one finds exact matches and the other matches
 everything. There are options that are a balance between the two extrems. 

 We can search for a literal pattern with some flexibility with character classes. 
 Character classes allow us to define a group of character we wish to match by placing
 them inside square ( [and] ) brackets. 


 For example, we want to match "bag", "big", and "bug" but not "bog". We can create 
 the regrex /b[aiu]g/ to do this 
 The [aiu] is the character class that will only match the characters
 "a","i", or "u". 


 -----------------------------------------

 let bigStr = "big";
 let bagStr = "bag";
 let bugStr = "bug";
 let bogStr = "bog";
 let bgRegex = /b[aiu]g/; 
 bigStr.match(bgRegex);   //returns ["big"]
 bagStr.match(bgRegex);   //returns ["bag"]
 bugStr.match(bgRegex);   //returns ["bug"]
 bogStr.match(bgRegex);   //returns null

--------------------------------------------- 

Character sets to specify a group of characters to match. 

There is a built-in feature that makes this short and simple. 

Inside a character set, we can define a range of characters to match using a hyphen character : - - 

For example, to match lowercase letters a thourh e we would use [ a - e] 

let catStr = "cat";
let batStr = "bat";
let matStr = "mat"; 
let bgRegex = /[a-e]at/; 
catStr.match(bgRegex);  //Returns  ["cat"]
catStr.match(bgRegex);  //Returns  ["bat"]
mstStr.match(bgRegex);  //Returns null


------------------------------------------------------

Use the hyphen ( - ) to match a range of characters is not limited to letters. It also works to match a range of numbers. 

For example, /0-5/ matches any number between 0 and 5 , including the 0 and 5. 

also, it is possible to combine a range of letters and numbers in a single character set.

let jennyStr = "Jenny86755309"; 
let myRegex = /a-z0-9/ig; 
//matches all leters and numbers in jennyStr
jennyStr.match(myRegex); 

---------------------------------------------------

We have created a set of characters that we want to match, but us could aslo create
 a set of characters that we don't  want to match. These types of characters sets
 are called 'negated character set'.

 we place a caret character (^) after the opening bracket and before the character we don't want to match. 

 For example /[^aeiou]/gi matcher all character that are not vowel. 
 
 bracket like . , !,  , @ , / 











