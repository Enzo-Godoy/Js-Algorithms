Introduction to oop. 
Object Oriented Programming 
At its core, software development solves a problem or achieves a result with computation. 
The software development process first defines a problem, then presents a solution. 

As its name implies, object oriented programming organizes code into object definitions, These are sometimes called classes, and they group together data with related behavier. 

The data is an object's attributes, and the behavior(or functions)are methods. 

The object structure makes it flexivle within a program. Objects can transfer information by calling and passing data to another object's methods. Also, new classes can receive, or inherit, all the feature from a base or parent class. This helps to reduce repeated code. 

Our choice of programming approach depends on a few factors. These include the type of problem, as well as how we want to structure our data and algorithms. 

Objects : Things people see everyday. These are all objects : tangiable things people can observe and interact with. 

The qualities or properties, define what makes up an object. Note that similar objects share the same properties, but may have different values for those properties. 

Objects in Js are used to modelr eal-world objects, giving them properties and behavier just like their ral-world counterparts. 


Example 

let duck = {
	name : "Aflac",
	numLegs : 2 
};

----------------------------------------------

Using dot notation. 
object name followed by the name of the property name to access the value. 


Objects can have a special type of property, called a method. 

Methods are properties that are functions. This adds different behavior to an object. 

Example. 
let duck = {
	 name : "Aflac",
	 numLegs : 2, 
	 sayName : function() {return "the name of this duck is " + duck.name + "."}
};

duck.sayName();
// Returns " The name of this duck is Aflac."


Make code more reusable with the this keyword. 


sayName : function() { return "The name of this duck is " + duck.name + ".";}


/// While this is a valid way to access the object's propert, there is a pitfall here. If the variable name changes, any code referencing the original name would need to be updated as well. In a short object definition, it isn't a problem, but if an object has many references to its properties there is a greater chance for error. 



We can avoid these issues is with the this keyword. 

let duck = {
	 name : "Aflac", 
	 numLegs : 2, 
	 sayName : function () { return "The name of this duck is " + this.name + ".";}
};



this is a deep topic, and the above example is only one way to use it. In the current context this refers to the object that the method is associated with : duck. 


Constructors are functions that create new objects. They define properties and behaviors that will belong to the new object. 

Example of a constructor 

function Bird () {
	 this.name = "Albert"; 
	 this.color = "blue"; 
	 this.numLegs = 2 ; 
}



//Constructors often follows a few conventions 

Constructors are defined with  a capitalized name to distinguish them from other functions that are not constructots. 

Constructors use the keywords this to set properties of the object they will create. 
Inside the constructor, this refers to the new object it will create. 

Constructors define properties and behaviors instead of returnin a value as other functions might. 



Use a constructor to create objects. 

Example 

function Bird () {
	 this.name = "Albert"; 
	 this.color = "blue"; 
	 this.numLegs = 2; 
	 // "this" inside the constructor always refers to the object being created 
}

let blueBird = new Bird();


//Notice that the new operator is used when calling a constructor.
Without the new operator, this inside the constructor would not point to the newly created object, giving unexpected results. 

blueBirds - has all the properties defined inside the Bird constructor. 


-----------------------------------------

Extend constructors to receive arguments. 

function Bird (name, color) {
	this.name = name ; 
	this.color = color ; 
	this.numLegs = 2; 
}

Then pass in the values as arguments to define each unique bird into the Bird constructor. 

let cardinal = new Bird ("Bruce", "red");
}

With this the constructor is more flexible. 
They group objects together based on shared characteristics and behavior and define a blueprin that automates their creation. 


Verify an Object's construct eith instanceof 

Anytime a constructor functions creates a new object, that object is said to be an instance of its constructor. JS gives a convenient way to verify this with the instanceof operator. 
instanceof allows us to compare an object to a constructor, returnin true or false based on wheter or not that object was created with the constructor. 

Example : 

let Bird = function () { 
 this.name = name ; 
 this.color = color; 
 this.numLegs = 2; 
}

let crow = new Bird ("Alexis", "black"); 

crow instanceof Bird; // => true


If an object is created without using a constructor, instanceof will verify that it is not an instance of that constructor. 


example 2 :

let canary = { 
 name : "Mildred", 
 color : "Yellow", 
 numLegs : 2 
 }; 

 canary instance of Bird; // => false

 Understand Own properties. 

 Example 

 function Bird (name) { 
  this.name = name ; 
  this.numLegs = 2 ; 
 }

 let duck = new Bird ("Donald");
 let canary = new Bird ("Tweety");



 name and numLegs are called own properties, because they are defined directly on the instance object. 


 The following code adds all of the own properties of duck to the array ownProps : 

 let ownProps = []; 

 for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
   ownProps.puush(property);
  }
 }

 console.log(ownProps);  //prints ["name", "numLegs"]


 Use protype properties to reduce duplicate code 

Got duplicates may not be an issue when there are only two instances, but imagine if there are millions of instances. That would be a lot of duplicated variables. 

Using class prototype avoid this. The proptotype is an object that is shared among all instances of class. 

Example with Bird prototype. 

Bird.prototype.numLegs = 2 ; 

Now all instances of bird have the numLegs property. 

console.log(duck.numLegs);  // prints 2 
console.log(canary.numLegs);  //prints 2 

Since all instances automatically have the properties on the prototype, think of a prototype as a "recipe" for creating objects.


Nearly every object in Js has a prototypr property wich is part of the constructor function that created it. 


We've seen two kinds of properties : own properties and prototype properties. Own properties are defined directly on the object instance itself. And prototype properties are defined on the prototype. 

Examples:

function Bird(name) {
	 this.name = name ; // own property 
}
Bird.prototype.numLegs = 2 ; // protype property 

let duck = new Bird ("Donald"); 

Here is how you add duck's own properties to the array ownProps and prototype properties to the array prototypeProps : 

let ownProps = [] ; 
let prototypeProps = []; 

for( let property in duck) { 
  if(duck.hasOwnProperty(property)){ownProps.push(property);}

  else {  prototypeProps.push(property)  }
}

console.log(ownProps);  //prints ["name"] 
console.log(prototypeProps);  //prints ["numLegs"]


Understand the constructor property 

There is a special constructor propert located on the object instances .

Constructor property is a reference to the constructor function that created the instance. 

The advantage of the constructor property is that it's possible to check for this property to find out what kind of object it is.


First example 

let duck  = new Bird (); 
let beagle = new Dog(); 

console.log(duck.constructor === Bird);  //prints true 
console.log(beagle.constructor === Dog);   /prints true. 

Second. 

function joinBirdFraternity (candidate) { 
  if (candidate.constructor === Bird) {
    return true ; 
  }  else { 
    return false; 
  }
} 

Since the constructor property can ve overwritten (wich will be covered in the next two challenges) it's generally better to use the instanceof method to check the type of an object. 

Up until now we have been adding properties to the prototype individually , this becomes tedious after more than a few properties. 


Example 

Bird.prototype.eat = function  () { 
    console.log("nom nom nom"); 
 }

 Bird.prototype.describe = function () { 
    console.log ("My name is " + this.name); 
 }

A more efficient way is to set the prototype to a new object that already contains the properties. This way, the properties are added all at once : 

Bird.prototype = { 
   numLegs : 2, 
   eat : function () { 
     console.log("nom nom nom"); 
     }, 
     describe : function () { 
       consle.log("My name is " + this.name); 
     }
}; 


Remember to set the constructor property when changing the protype  

There is one crucial side effect of manually setting the prototype to a new object. It erased the constructor property! The code in the previous challenge would print the following for duck : 

console.log(duck.constructor)
// prints 'undefined' - Oops!

To fix this, whenever a prototype is manually set to a new object,we need to remember re defined the constructor property. 


Bird.prototype = { 
 constructor : Bird, // define the constructor property
 numLegs : 2, 
 eat : function () {
    console.log("nom nom nom"); 
  }, 
  describe : function () { 
    console.log(My name is " + this.name); 
  }
}; 



Understand where an object's prototype comes from . 

Just like people inherit genes from their parents, an object inherits its prototype directly from the constructor function that created it. 

Example . duck from Bird

function Bird (name) { 
  this.name = name ; 
 }

 let duck = new Bird ("Donald"); 

duck inherits its prototype from the birds constructor function . We can show this relationship with the isPrototypeOf method: 

Bird.prototype.isPrototypeOf(duck); 
// returns true. 



Understant the Prototype Chain . 

All objects in Js (with a few exceptions) have a prototype. Also, an object's prototype itself is an object. 

function Bird (name) { 
   this.name = name ; 
}

typeof  Bird.prototype;   // => object 

cuz a prototype is an object, a prototype can have its own prototype! in this case, the prototype of Bird.prototype is Object.prototype 

Object.prototype.isPrototypeOf(Bird.prototypr); 
// returns true.

The hasOwnProperty method is defined in Object.prototype, wich can be accessed by Bird.prototype, wich can then be accessed by duck, This is an ecample of the prototype chain .

In this prototype chain, Bird is the supertype for duck, while duck is the subtype. 
Object is a supertype for both Bird and duck. 

Object is a supertype for all objects in Javascript. Therefore, any object can use the hasOwnProperty method.

Use inheritance so you don't repeat yourself. 

DRY(don't repeat yourself never heard of it). 
They reason repeated code is a problem is because any change requires fixing code in multiple places. 

This usually means more works for programmers and more room for errors. 

In the next example describe method is shared by Bird and Dog. 

Bird.prototype = { 
   constructor : Bird, 
    descrbie : function ()  { 
      console.log("my name is" + this.name);
      }
}; 


Dog.prototype = { 
   constructor : Dog , 
   describe : function () {
    console.log ("My name is " + this.name);
   } 
}; 

The describe method is repeated in two places. The code can be edited to follow the DRY principle by creating a supertype (or parent) called Animal : 

function Animal () {
	constructor : Animal, 
	describe : function () { 
	  console.log ("My name is  " + this.name); 
	 }
}; 

Since animal includes the describe method, we can remove it from Bird and Dog : 

Bird.prototype = { 
  constructor : Bird
}; 

Dog.prototype =  { 
  constructor : Dog 
}; 



Inherit Behaviors from a Supertype 
Example : 

function Animal () {}
Animal.prototypr.eat = function () { 
 console.log("nom nom nom"); 

}; 

We need to rehuse the method inside our object without defininf then again. To do this we a use a technique called inheritance. 

Make an instance of the supertype (or parent) 

We already know one way to create an instance of Animal using the new operator. 

There are some disadventages when using this syntax for inheritance wich are too complex for the scope .


let animal = Object.create(Animal.protype); 

Object.create(obj) creates a new object, and sets obj as the new object's prototype. 

Recall that the prototype is like the "recipe" for creating an object. By setting the prototype of animal to be Animal's prototype, we are effectively giving the animal instance the same "recipe" as any other instance of Animal. 

animal.eat(); //prints "nom nom nom"

Set the Child's prototype to an instance of the parent. 

Set the prototype of the subtype(or child). 

Bird.prototype = Object.create(Animal.prototype); 

Remeber i'm not just copying all, you really think that, well i'm aware of that and dissapointed on you, try again. 

let duck = new Bird("Donald"); 
duck.eat();  //prints "nom nom nom"

duck inherits all of Animal's properties, including the eat method. 

Reset an inherited Constructor Property. 

When an object inherits its prototype from another object, it also inherits the supertype's constructor property. 

Example :

function Bird ()  { }
Bird.prototype = Object.create(Animal.protype); 
let duck = new Bird(); 
duck.constructor // function Animal () {...}

But duck and all instances of Bird should show that they were constructed by Bird and not Animal. To do so, we can manually set bird's constructor property to the bird object : 

Bird.prototpye.constructor = Bird ; 
duck.constructor // function Bird () {...}

function Animal() { }
Animal.prototype.eat = function() { console.log("nom nom nom"); };

function Dog() { }
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.bark = function () {console.log("Woof!");}




let beagle = new Dog();

beagle.eat(); 
beagle.bark(); 

Override inherited methods. 

We've learned that an object can iherit its behavior (methods) from another object by clonin its prototype object : 

ChildObject.prototype = Object,create(ParentObject.prototype); 

Then the ChildObject received iits own method by chaining them onto its prototype : 

ChilObject.prototype.methodName = function() {...}; 

It's possible to everride an inherited method. it's done the same way - by adding a method to childObject.prototype using the same method name as the one to override. 

Example of overriding the eat() method inherited from Animal : 

function Animal () { }
Animal.prototype.eat = function () {  return "nom nom nom" };

function Bird () { }

// Inherit all method from Animal 
Bird.prototype = Object.create(Animal.prototype); 

//Bird.eat() overrides Animal.eat() 
Bird.prototype.eat = function () { 
    return "peck peck peck";
}; 


If we have an instance   let duck = new Bird () ; and we call duck.eat(), this is how Js looks for the method on duck's prototype chain : 

1. duck => Is eat() defined here ? No.

2. Bird => Is eat() defined here ? Yes. Execute it and stop searching.

3. Animal => Is eat() defined here ? is also defined, but Js stopped searching before reaching this level.

4. Object => Is eat() defined here ? Js stopped searching before reaching this level.


Use a Mixin to add common behavior between unrelated objects. 

As we have seen, behavior is shared though inheritance. However, there cases when inheritance is not the best solution. Inheritances does not work well for unrelated objects like Bird and Airplance. 
For unrelated objects, it's better to use mixinx. A mixin allows other object to use a collection of functions. 

let flyMixin = function(obj) { 
  obj.fly = function () { 
  console.log("Flying, wooosh!");
  }
};

The flyMixin takes any object and gives it the fly method. 

let bird = { 
 name : "Donald", 
 numLegs : 2
}; 

let plane = { 
  model : "777",
  numPassengers : 524
}; 


flyMixin(bird); 
flyMixin(plane); 


Here bird and plane are passed into flyMixin, wich then assigns the fly function to each object, Now bird and plane can both fly: 

bird.fly();  // prints "Flying, wooosh!"
plane.fly();  // prints "Flying, wooosh!"

Note how the mixin allows for the same fly method to be reaused by unrelated objects bird and plane. 


Use closure to protect properties within an object from Being Modified Externally. 

The public property are considered public because it can ba accessed and changed outside of bird's definition. 

example : 

bird.name = "Larah"; 

Therefore, any part of our code can easily change the name of bird to any value. Think about thing like passwords and bank accounts being easily changeable by any part of our codebase. 

The simples way to make properties private is by creating a variable within the constructor function versus available globally. This way, the property can only be accessed and change by methods also within the constructor function.


function Bird()  { 
   let hatchedEgg = 10  // private property 

 // publicly available method that a bird object can use
   this.gatHatchedEggCount = function ()  { 
			return hatchedEgg; };
}


 let ducky = new Bird (); 
 ducky.getHatchedEggCount();   // returns 10.


 Here hetHachedEggCount is a privileged method, because it has access to the private variable hatchedEgg. This is possible because hatchedEgg is declared in the same context as getHachedEggCount. In Js, a function always has access to the context in wich it was created. This is called closure. 


 Understand the immediately invoked function expression (IIFE)

 A common patter in Js is to execute a function as soon as it is declared. 


//This is an anonymous function expression that executes right away.
 (function () { 
  console.log("Chirp, chirp!"); 
  })  ();

 // Outputs "Chirp, chirp!" immediately


 Note that the function has no name and is not stored in a variable. The two parentheses () at the end of the funtion expression cause it to be immediately executed or invoked. This pattern is known as an immediately invoked function expression or IIFE. 

 Use an IIFE to create a Module 

 An immediately invoked function expression(IIFE) is often used to group related functionality into a single object or module. 

 example 


 function glideMixin(obj) { 
   obj.glide = function() { 
  console.log ("Gliding on the water"); 
 }; 
}

function flyMixin(obj) { 
  obj.fly = function() { 
    console.log("Flying, wooosh!"); 
   };
}


We can group these mixins into a module as follows. 

let motionModule = (function () { 
  return { 
    glideMixin : function (obj)  {
       console.log("Gliding  on the water");
       };
  },
  flyMixin : function (obj)  { 
   obj.fly = function () { 
     console.log("Flying, wooosh!"); 
     };
    }
  }
}) (); 

//The two parentheses cause the function to be inmediately onvoked.



Note that now we have an immediately invoked function expression (IIFE) that returns an object motionModule. This returned object contains all of the mixin behaviors as properties of the object.


The advantage of the module pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of our code. 

example of using it. 

motionModule.glideMixin(duck); 
duck.glide(); 



})
