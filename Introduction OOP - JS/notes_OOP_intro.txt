Introduction to oop. 
Object Oriented Programming : 
Object oriented programming organizes code into objects definitions, these are derived from classes. (Theory) 

And this classes represents objects group together with related behaviour.

#JS 
The data in an object it's an attribute, 
and the behaviour are functions .

Objects can transfer information by calling and passing data to another object's method. 

Objects are represented by things that we see everyday. Tangible things that we can oberve and interact with. 
The properties defines what makes up an object. 

Objects in JS are use to model real-world object, giving them properties and behaviour just like their real-world 
counterparts. 

 E.G : 
 let duck = { 
 	name : "Aflack", 
 	numberLegs : 2;
 }; 

 -- Accessing properties 
 We can acces the properties of an object by using 'dot notation' this means, 
 the name of the object followed by the property when the value need it's hold. 

 E.G 
 let nameDuck = duck.name; 

 Objects can obtain behaviour representation by adding in their properties functions 
 E.G  : 
 let duck = {
 	name : "Aflack",
 	numberLegs : 2, 
 	sayName : function() { return "The name of the duck" + duck.name }
 }; 

 duck.sayName();

/* 
To avoid the constraint of reference properties within an object  that cna be changed afterward, the 'this' keyword 
can be use in order to extract values from the same context.
*/
E.G  : 
.. 
	sayName : function {  return "The name of the duck is" + this.duck}
.. 


/*
 Constructos are functions that create the basic scheme for an object specifed . They define specific behaviour 
that will belong to each object created 
*/
E.G : 
function Bird(){
	this.name = "Albert"; 
	this.color = "Blue"; 
	this.numberLegs = 2; 
}
 
/*
 ## Constructors follows a conventions where they use a capitalized name to be distinguished from other functions. 
 # Also they are used to set properties and behaviour instead of make some task or return a value.
	In order to manipulate values to be added to each object created from  a constructor the 'this' keyword 
	it's used.
*/

E.G : 
function Bird() {
	this.name  = "SomeName"; 
	this.color = "Blue"; 
	this.numberLegs = 2; 
}

-- Each object created from the before constructor will acquire the same properties 
let blueBird = new Bird(); 


/* Sample with constructor that takes parameters */ 
function Bird(name, color) { 
	this.name = name ; 
	this.color = color; 
	this.numberLegs = 2; 
}

let myBirdPet = new Bird("Bruce", "Red and Yello"); 

/* 
 To detect where an objects it's related to 'x' constructor we can use the function instanceOf provide by
 the api of JS I think so. 
*/ 

E.G : 
let Bird = function(){ 
	this.name = name; 
	this.color = color; 
	this.numberLegs = 2; 
}

let crow = new Bird("Alexis", "White"); 
crow instanceof Bird;  /* It will return true */ 
 

 
/* 
 use prototype properties to reduce duplicate code. 
 Until now we know two kinds of properties : 
 	(a) - * Own Properties. 
    (b) - * Prototypes properties. 
a: Define directly on the object instance itself. 
b: Are defined on the prototype.

The advantage of the constructor property is that it's possible to check for this property to find out what kind 
of object it is.
*/
  
-- Sample of a behaviour add to the prototype 
Bird.prototype.eat = function(){ 
	console.log("Quiet sound made during eating");
}

-- Sample of bahaviour added to an object within a prototype aggregated value 
Bird.prototype = { 
	numberLegs = 2, 
	eat : function(){
		console.log("Silece while eating");
	}, 
	describe : function(){
		console.log("My name is" + this.name);
	}
}; 
 

 /* 
 Code in the prototype can be deleted the code from the constructor property, be carefull!
 We could avoid this by re-defining the constructor property for the same  object.
 */
 E.G : 
 Bird.Prototype = {
 	constructor: Bird, 
 	numberLegs : 2, 
 	eat : function(){ 
 		console.log("Silenc while eating"); 
 	},
 	describe: function(){ 
 		console.log("My name is" + this.name);
 	}
};

/* 
We can know the prototype inheritance by using 'isPrototypeOf' function. 

Bird.prototype.isPrototypeOf(duck);
All object in Js (With a few exceptions) has a prototype. An object's prototype itself 
is an object. 

function Bird(name){ 
	this.name = name;
}

typeOf Bird.protype;  /* =>>> Object */ 

 /* 
 A Great example of prototype chain it's the 'hasOwnProperty' function. 
 it's defined in Object.prototype, wich can be acessed by Bird.prototype and a its time by 'duck'

  Duck (subType) > Bird (superType).

  Object is a supertype for all objects in Javascript. And for this any object can use the 'hasOwnProperty' method. 

  Concept >> D.R.Y (Don't Repeat Yourself)

*/ 

-- Sample of two Constructor being Cleaned to avoid repetition of behaviour 
Bird.prototype = { 
	constructor : Bird, 
	describe : function(){ 
		console.log("My name is " + this.name);
	}
}; 

Dog.prototype = { 
	constructor : Dog, 
	describe : function(){ 
		console.log("My name is" + this.name);
	}
}; 

 /* Both of the them implments the same describe function, solved by using the DRY concept 
 Adding the same behaviour to the superType (parent) of boths 'Animales'*/
 function Animal(){ 
 	constructor: Animal, 
 	describe: function(){ 
 		console.log("My name is:" + this.name);
 	}
 };

 Bird.prototype = { 
 	constructor = 'Bird';
 };
 Dog.prototype = { 
 	constructor = 'Bird';
 };


 

Inherit Behaviors from a Supertype 
Example : 

function Animal () {}
Animal.prototypr.eat = function () { 
 console.log("nom nom nom"); 

}; 

We need to rehuse the method inside our object without defininf then again. To do this we a use a technique called inheritance. 

Make an instance of the supertype (or parent) 

We already know one way to create an instance of Animal using the new operator. 

There are some disadventages when using this syntax for inheritance wich are too complex for the scope .


let animal = Object.create(Animal.protype); 

Object.create(obj) creates a new object, and sets obj as the new object's prototype. 

Recall that the prototype is like the "recipe" for creating an object. By setting the prototype of animal to be Animal's prototype, we are effectively giving the animal instance the same "recipe" as any other instance of Animal. 

animal.eat(); //prints "nom nom nom"

Set the Child's prototype to an instance of the parent. 

Set the prototype of the subtype(or child). 

Bird.prototype = Object.create(Animal.prototype); 

Remeber i'm not just copying all, you really think that, well i'm aware of that and dissapointed on you, try again. 

let duck = new Bird("Donald"); 
duck.eat();  //prints "nom nom nom"

duck inherits all of Animal's properties, including the eat method. 

Reset an inherited Constructor Property. 

When an object inherits its prototype from another object, it also inherits the supertype's constructor property. 

Example :

function Bird ()  { }
Bird.prototype = Object.create(Animal.protype); 
let duck = new Bird(); 
duck.constructor // function Animal () {...}

But duck and all instances of Bird should show that they were constructed by Bird and not Animal. To do so, we can manually set bird's constructor property to the bird object : 

Bird.prototpye.constructor = Bird ; 
duck.constructor // function Bird () {...}

function Animal() { }
Animal.prototype.eat = function() { console.log("nom nom nom"); };

function Dog() { }
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.bark = function () {console.log("Woof!");}




let beagle = new Dog();

beagle.eat(); 
beagle.bark(); 

Override inherited methods. 

We've learned that an object can iherit its behavior (methods) from another object by clonin its prototype object : 

ChildObject.prototype = Object,create(ParentObject.prototype); 

Then the ChildObject received iits own method by chaining them onto its prototype : 

ChilObject.prototype.methodName = function() {...}; 

It's possible to everride an inherited method. it's done the same way - by adding a method to childObject.prototype using the same method name as the one to override. 

Example of overriding the eat() method inherited from Animal : 

function Animal () { }
Animal.prototype.eat = function () {  return "nom nom nom" };

function Bird () { }

// Inherit all method from Animal 
Bird.prototype = Object.create(Animal.prototype); 

//Bird.eat() overrides Animal.eat() 
Bird.prototype.eat = function () { 
    return "peck peck peck";
}; 


If we have an instance   let duck = new Bird () ; and we call duck.eat(), this is how Js looks for the method on duck's prototype chain : 

1. duck => Is eat() defined here ? No.

2. Bird => Is eat() defined here ? Yes. Execute it and stop searching.

3. Animal => Is eat() defined here ? is also defined, but Js stopped searching before reaching this level.

4. Object => Is eat() defined here ? Js stopped searching before reaching this level.


Use a Mixin to add common behavior between unrelated objects. 

As we have seen, behavior is shared though inheritance. However, there cases when inheritance is not the best solution. Inheritances does not work well for unrelated objects like Bird and Airplance. 
For unrelated objects, it's better to use mixinx. A mixin allows other object to use a collection of functions. 

let flyMixin = function(obj) { 
  obj.fly = function () { 
  console.log("Flying, wooosh!");
  }
};

The flyMixin takes any object and gives it the fly method. 

let bird = { 
 name : "Donald", 
 numLegs : 2
}; 

let plane = { 
  model : "777",
  numPassengers : 524
}; 


flyMixin(bird); 
flyMixin(plane); 


Here bird and plane are passed into flyMixin, wich then assigns the fly function to each object, Now bird and plane can both fly: 

bird.fly();  // prints "Flying, wooosh!"
plane.fly();  // prints "Flying, wooosh!"

Note how the mixin allows for the same fly method to be reaused by unrelated objects bird and plane. 


Use closure to protect properties within an object from Being Modified Externally. 

The public property are considered public because it can ba accessed and changed outside of bird's definition. 

example : 

bird.name = "Larah"; 

Therefore, any part of our code can easily change the name of bird to any value. Think about thing like passwords and bank accounts being easily changeable by any part of our codebase. 

The simples way to make properties private is by creating a variable within the constructor function versus available globally. This way, the property can only be accessed and change by methods also within the constructor function.


function Bird()  { 
   let hatchedEgg = 10  // private property 

 // publicly available method that a bird object can use
   this.gatHatchedEggCount = function ()  { 
			return hatchedEgg; };
}


 let ducky = new Bird (); 
 ducky.getHatchedEggCount();   // returns 10.


 Here hetHachedEggCount is a privileged method, because it has access to the private variable hatchedEgg. This is possible because hatchedEgg is declared in the same context as getHachedEggCount. In Js, a function always has access to the context in wich it was created. This is called closure. 


 Understand the immediately invoked function expression (IIFE)

 A common patter in Js is to execute a function as soon as it is declared. 


//This is an anonymous function expression that executes right away.
 (function () { 
  console.log("Chirp, chirp!"); 
  })  ();

 // Outputs "Chirp, chirp!" immediately


 Note that the function has no name and is not stored in a variable. The two parentheses () at the end of the funtion expression cause it to be immediately executed or invoked. This pattern is known as an immediately invoked function expression or IIFE. 

 Use an IIFE to create a Module 

 An immediately invoked function expression(IIFE) is often used to group related functionality into a single object or module. 

 example 


 function glideMixin(obj) { 
   obj.glide = function() { 
  console.log ("Gliding on the water"); 
 }; 
}

function flyMixin(obj) { 
  obj.fly = function() { 
    console.log("Flying, wooosh!"); 
   };
}


We can group these mixins into a module as follows. 

let motionModule = (function () { 
  return { 
    glideMixin : function (obj)  {
       console.log("Gliding  on the water");
       };
  },
  flyMixin : function (obj)  { 
   obj.fly = function () { 
     console.log("Flying, wooosh!"); 
     };
    }
  }
}) (); 

//The two parentheses cause the function to be inmediately onvoked.



Note that now we have an immediately invoked function expression (IIFE) that returns an object motionModule. This returned object contains all of the mixin behaviors as properties of the object.


The advantage of the module pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of our code. 

example of using it. 

motionModule.glideMixin(duck); 
duck.glide(); 



})
