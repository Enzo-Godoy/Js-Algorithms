function Animal() { }
Animal.prototype.eat = function() { console.log("nom nom nom"); };

function Dog() { }
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.bark = function () {console.log("Woof!");}




let beagle = new Dog();

beagle.eat(); 
beagle.bark(); 

Override inherited methods. 

We've learned that an object can iherit its behavior (methods) from another object by clonin its prototype object : 

ChildObject.prototype = Object,create(ParentObject.prototype); 

Then the ChildObject received iits own method by chaining them onto its prototype : 

ChilObject.prototype.methodName = function() {...}; 

It's possible to everride an inherited method. it's done the same way - by adding a method to childObject.prototype using the same method name as the one to override. 

Example of overriding the eat() method inherited from Animal : 

function Animal () { }
Animal.prototype.eat = function () {  return "nom nom nom" };

function Bird () { }

// Inherit all method from Animal 
Bird.prototype = Object.create(Animal.prototype); 

//Bird.eat() overrides Animal.eat() 
Bird.prototype.eat = function () { 
    return "peck peck peck";
}; 


If we have an instance   let duck = new Bird () ; and we call duck.eat(), this is how Js looks for the method on duck's prototype chain : 

1. duck => Is eat() defined here ? No.

2. Bird => Is eat() defined here ? Yes. Execute it and stop searching.

3. Animal => Is eat() defined here ? is also defined, but Js stopped searching before reaching this level.

4. Object => Is eat() defined here ? Js stopped searching before reaching this level.


Use a Mixin to add common behavior between unrelated objects. 

As we have seen, behavior is shared though inheritance. However, there cases when inheritance is not the best solution. Inheritances does not work well for unrelated objects like Bird and Airplance. 
For unrelated objects, it's better to use mixinx. A mixin allows other object to use a collection of functions. 

let flyMixin = function(obj) { 
  obj.fly = function () { 
  console.log("Flying, wooosh!");
  }
};

The flyMixin takes any object and gives it the fly method. 

let bird = { 
 name : "Donald", 
 numLegs : 2
}; 

let plane = { 
  model : "777",
  numPassengers : 524
}; 


flyMixin(bird); 
flyMixin(plane); 


Here bird and plane are passed into flyMixin, wich then assigns the fly function to each object, Now bird and plane can both fly: 

bird.fly();  // prints "Flying, wooosh!"
plane.fly();  // prints "Flying, wooosh!"

Note how the mixin allows for the same fly method to be reaused by unrelated objects bird and plane. 


Use closure to protect properties within an object from Being Modified Externally. 

The public property are considered public because it can ba accessed and changed outside of bird's definition. 

example : 

bird.name = "Larah"; 

Therefore, any part of our code can easily change the name of bird to any value. Think about thing like passwords and bank accounts being easily changeable by any part of our codebase. 

The simples way to make properties private is by creating a variable within the constructor function versus available globally. This way, the property can only be accessed and change by methods also within the constructor function.


function Bird()  { 
   let hatchedEgg = 10  // private property 

 // publicly available method that a bird object can use
   this.gatHatchedEggCount = function ()  { 
			return hatchedEgg; };
}


 let ducky = new Bird (); 
 ducky.getHatchedEggCount();   // returns 10.


 Here hetHachedEggCount is a privileged method, because it has access to the private variable hatchedEgg. This is possible because hatchedEgg is declared in the same context as getHachedEggCount. In Js, a function always has access to the context in wich it was created. This is called closure. 


 Understand the immediately invoked function expression (IIFE)

 A common patter in Js is to execute a function as soon as it is declared. 


//This is an anonymous function expression that executes right away.
 (function () { 
  console.log("Chirp, chirp!"); 
  })  ();

 // Outputs "Chirp, chirp!" immediately


 Note that the function has no name and is not stored in a variable. The two parentheses () at the end of the funtion expression cause it to be immediately executed or invoked. This pattern is known as an immediately invoked function expression or IIFE. 

 Use an IIFE to create a Module 

 An immediately invoked function expression(IIFE) is often used to group related functionality into a single object or module. 

 example 


 function glideMixin(obj) { 
   obj.glide = function() { 
  console.log ("Gliding on the water"); 
 }; 
}

function flyMixin(obj) { 
  obj.fly = function() { 
    console.log("Flying, wooosh!"); 
   };
}


We can group these mixins into a module as follows. 

let motionModule = (function () { 
  return { 
    glideMixin : function (obj)  {
       console.log("Gliding  on the water");
       };
  },
  flyMixin : function (obj)  { 
   obj.fly = function () { 
     console.log("Flying, wooosh!"); 
     };
    }
  }
}) (); 

//The two parentheses cause the function to be inmediately onvoked.



Note that now we have an immediately invoked function expression (IIFE) that returns an object motionModule. This returned object contains all of the mixin behaviors as properties of the object.


The advantage of the module pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of our code. 

example of using it. 

motionModule.glideMixin(duck); 
duck.glide(); 



})