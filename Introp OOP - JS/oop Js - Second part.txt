Understand the constructor property 

There is a special constructor propert located on the object instances .

Constructor property is a reference to the constructor function that created the instance. 

The advantage of the constructor property is that it's possible to check for this property to find out what kind of object it is.


First example 

let duck  = new Bird (); 
let beagle = new Dog(); 

console.log(duck.constructor === Bird);  //prints true 
console.log(beagle.constructor === Dog);   /prints true. 

Second. 

function joinBirdFraternity (candidate) { 
  if (candidate.constructor === Bird) {
    return true ; 
  }  else { 
    return false; 
  }
} 

Since the constructor property can ve overwritten (wich will be covered in the next two challenges) it's generally better to use the instanceof method to check the type of an object. 

Up until now we have been adding properties to the prototype individually , this becomes tedious after more than a few properties. 


Example 

Bird.prototype.eat = function  () { 
    console.log("nom nom nom"); 
 }

 Bird.prototype.describe = function () { 
    console.log ("My name is " + this.name); 
 }

A more efficient way is to set the prototype to a new object that already contains the properties. This way, the properties are added all at once : 

Bird.prototype = { 
   numLegs : 2, 
   eat : function () { 
     console.log("nom nom nom"); 
     }, 
     describe : function () { 
       consle.log("My name is " + this.name); 
     }
}; 


Remember to set the constructor property when changing the protype  

There is one crucial side effect of manually setting the prototype to a new object. It erased the constructor property! The code in the previous challenge would print the following for duck : 

console.log(duck.constructor)
// prints 'undefined' - Oops!

To fix this, whenever a prototype is manually set to a new object,we need to remember re defined the constructor property. 


Bird.prototype = { 
 constructor : Bird, // define the constructor property
 numLegs : 2, 
 eat : function () {
    console.log("nom nom nom"); 
  }, 
  describe : function () { 
    console.log(My name is " + this.name); 
  }
}; 



Understand where an object's prototype comes from . 

Just like people inherit genes from their parents, an object inherits its prototype directly from the constructor function that created it. 

Example . duck from Bird

function Bird (name) { 
  this.name = name ; 
 }

 let duck = new Bird ("Donald"); 

duck inherits its prototype from the birds constructor function . We can show this relationship with the isPrototypeOf method: 

Bird.prototype.isPrototypeOf(duck); 
// returns true. 



Understant the Prototype Chain . 

All objects in Js (with a few exceptions) have a prototype. Also, an object's prototype itself is an object. 

function Bird (name) { 
   this.name = name ; 
}

typeof  Bird.prototype;   // => object 

cuz a prototype is an object, a prototype can have its own prototype! in this case, the prototype of Bird.prototype is Object.prototype 

Object.prototype.isPrototypeOf(Bird.prototypr); 
// returns true.

The hasOwnProperty method is defined in Object.prototype, wich can be accessed by Bird.prototype, wich can then be accessed by duck, This is an ecample of the prototype chain .

In this prototype chain, Bird is the supertype for duck, while duck is the subtype. 
Object is a supertype for both Bird and duck. 

Object is a supertype for all objects in Javascript. Therefore, any object can use the hasOwnProperty method.

Use inheritance so you don't repeat yourself. 

DRY(don't repeat yourself never heard of it). 
They reason repeated code is a problem is because any change requires fixing code in multiple places. 

This usually means more works for programmers and more room for errors. 

In the next example describe method is shared by Bird and Dog. 

Bird.prototype = { 
   constructor : Bird, 
    descrbie : function ()  { 
      console.log("my name is" + this.name);
      }
}; 


Dog.prototype = { 
   constructor : Dog , 
   describe : function () {
    console.log ("My name is " + this.name);
   } 
}; 

The describe method is repeated in two places. The code can be edited to follow the DRY principle by creating a supertype (or parent) called Animal : 

function Animal () {
	constructor : Animal, 
	describe : function () { 
	  console.log ("My name is  " + this.name); 
	 }
}; 

Since animal includes the describe method, we can remove it from Bird and Dog : 

Bird.prototype = { 
  constructor : Bird
}; 

Dog.prototype =  { 
  constructor : Dog 
}; 



Inherit Behaviors from a Supertype 
Example : 

function Animal () {}
Animal.prototypr.eat = function () { 
 console.log("nom nom nom"); 

}; 

We need to rehuse the method inside our object without defininf then again. To do this we a use a technique called inheritance. 

Make an instance of the supertype (or parent) 

We already know one way to create an instance of Animal using the new operator. 

There are some disadventages when using this syntax for inheritance wich are too complex for the scope .


let animal = Object.create(Animal.protype); 

Object.create(obj) creates a new object, and sets obj as the new object's prototype. 

Recall that the prototype is like the "recipe" for creating an object. By setting the prototype of animal to be Animal's prototype, we are effectively giving the animal instance the same "recipe" as any other instance of Animal. 

animal.eat(); //prints "nom nom nom"

Set the Child's prototype to an instance of the parent. 

Set the prototype of the subtype(or child). 

Bird.prototype = Object.create(Animal.prototype); 

Remeber i'm not just copying all, you really think that, well i'm aware of that and dissapointed on you, try again. 

let duck = new Bird("Donald"); 
duck.eat();  //prints "nom nom nom"

duck inherits all of Animal's properties, including the eat method. 

Reset an inherited Constructor Property. 

When an object inherits its prototype from another object, it also inherits the supertype's constructor property. 

Example :

function Bird ()  { }
Bird.prototype = Object.create(Animal.protype); 
let duck = new Bird(); 
duck.constructor // function Animal () {...}

But duck and all instances of Bird should show that they were constructed by Bird and not Animal. To do so, we can manually set bird's constructor property to the bird object : 

Bird.prototpye.constructor = Bird ; 
duck.constructor // function Bird () {...}

