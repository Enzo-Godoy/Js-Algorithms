Introduction to SaSS
Sass (Sintactically Awesome StyleSheets). 
is a language extension of CSS. It adds features that aren't available using basic Css syntax.  Sass makes it easier for developers to simplify and maintain the style sheets for their projects. 

Sass can extend the CSS language because it's a preprocessor. It takes code written using Sass syntax, and converts it into basic Css. 
This allos us to create variables, nest CSS rules into others, and import other Sass files, among other things. The result is more compact, easier to read code. 

There're two syntaxes available for Sass. The first, known as Scss (Sassy CSS) and use throughout freecodecamp challenge, is an extension of the syntax of CSS.  

The second and older syntax, known as the intdentend syntax (or sometime just"Sass"), uses indentation rather than brackets to indicate nesting of selectors, and newlines rather than semicolons to separate properties. Files using this syntax have the  .sass extension. 


Store data with Sass variables 
One feature of Sass that's different than Css is it uses variables. They're declared and set to store data, similar to Js. 

In js, variable are defined using the 'let' and 'const' keywords. In Sass, variables start with a $ followed by the variable name. 

Examples : 

$main-fonts: Arial, sans-serif; 
$headings-color : green; 

//To use variables : 
h1 {
	font-family: $main-fonts; 
	color : $heading-color;
}


//Sass allows nesting of CSS rules, wich is a useful way of organizing a style sheet. 


Example 

Css  
nav { 
	bg-color: red; 	
} 

nav ul { 
	list-style : none;
}

nav ul li { 
	display : inline-block; 
}

For a large project, the css file will have many lines and rules. This is where nesting can help organize our code by placing child style rules within the respective parent elements. 

nav { 
 background-color : red; 
    ul { 
        list-style:none; 

        li { 
       	    display: inline-block; 
           }
        }
   }



InSass, a mixin is a group of CSS declarations that can be reaused troughout the style sheet. 

Newer CSS features take time before they are fully adopted and ready to use in all browsers. As features are added to browsers, css rules usin them may need vendor prefixes. 

example Css

div {
  -webkit-box-shadow : 0px 0px 4px #fff; 
  -moz-box-shadow : 0px 0px 4px #fff;
  -ms-box-shadow : 0px 0px 4px #fff;
  box-shadow : 0ppx 0px 4px #fff;	
}

example SaSS 
@mixin box-shadow ($a,$b,$c,$dCol) { 
 -webkit-box-shadow : $a $a $a $dCol; 
  -moz-box-shadow : $a $b $c $dCol;
  -ms-box-shadow : $a $b $c $dCol;
  box-shadow : $a $b $c $dCol;
} 


//The definition starts with @mixin followed by a custom name. The paramers are optional. 

So any time a box-shadow rule is neeeded, only a single line calling the mixin replaces having to type all the vendor prefixes. A mixin is called with the @include directive : 

div {
	@include box-shadow (npx, npx, npx, #color);
}


Use @if and @else to add logic to our styles. 

The @if directive in Sass is useful to test for a specific case - it works just like the if statement in Js. 

@mixin make-bold($bool) { 
   @if $bool == true { 
    font-weight : bold; 
    }
}


And just like in Js @else if and Qelse test for more conditions : 

@mixin text-effect ($val) { 
	 @if $val == danger { 
	   color : red; 
	 }
	 @else if $val == alert { 
	   color : yellow; 
	 }
	 @else if $val == siccess { 
	   color: green;
	 }
	 @else { 
	   color: black;
	 }
 }

 Use @for to create a Sass loop. 
 The @for directive adds styles in a loop, very similar to a for loop in Js. 

 @for is used in two ways : "start through end" or "start to end". The main difference is that "start to end" excludes the end number, and "start thourgh end" includes the end number. 

 Through end example : 

 @for $i from 1 through 12 { 
 	.col-#{$1} {width: 100%/12 * $i; }
 } 

 The #{$i} part is the syntax to combine a variable (i) with text to make a string. When the Sass file is converted to CSS, it looks like this 


 .col-n {
   width: assign x n(i);
 }
  .col-2 {
   width: assign x n(2);
 }
  .col-3 {
   width: assign x n(2);
 }
  .col-4 {
   width: assign x n(3);
 }
 ...


interesting.


Use@each to map over items in a list. 

@each directive wich loops over each item in a list or map. 




On each iteration, the variable gets assigned to the current value from the list or map. 
@each $color in blue, red, green { 
	.#{$color}-text	 {color:$color;}
}


A map has slightly different syntax.  
Example : 

$colors: (
		   color1:blue,
		   color2: red,
		   color3: green 
);


@each $key, $color in $colors { 
	.#{$color}-text {color:$color;}
}

The $key variable is needed to reference the keys in the map. Otherwise, the compiled CSS would have color1, color2 ... in it. 

Both of this code are converted into the following CSS : 

.blue-text { 
  color: name;
} 

.red-text { 
  color: red;
} 


.green-text { 
  color: green;
}  


The @while directive is an option with similar functionality to the Js while loop. It creates CSS rules until a condition is met. 

Example : 

$x : 1; 
@while $x < 13 { 
 	.col-#{$x} { width: 100 %12 * $x;}
 	$x : $x + 1; 
}

Explanation of the code : 
 First, we've define a variable $x and set it to 1. Next, use the @while directive to create the grid system while $x is less than 13. 

After setting the CSS rule for width, $x is incremented by 1 to avoid an infinite loop. 

Partials in Sass are separate files that holds segments of Css code.       //These are imported and used in other Sass files. 
This is a great way to group similar code into a module to keep it organized. 


Names for partials start with the underscore ('_') character, wich tells Sass it's a small segment of Css and not to convert it into a Css file. Also, Sass files end with the .scss file extension. To bring the code in the code in the partial into another Sass file, use the @import directive. 

Example 

//Somo mixins in a file named "_mixins.scss" 

 //in other file in the same folder 
 @import 'mixins' 

 Nothe : The underscore isn't needed in the import statement - Sass understands it's a partial. Once a partial is imported into a file, all variables, mixins, and other code are available to use. 


 Extend one Set of Css styles to another Element. 
 Sass has a feature called extend that makes it easy to borrow the Css rules from one element and build upon them in another. 

 Example 

 .panel { 
 background-color : red; 
 height : 70px; 
 border : 2px solid green;
 }

.big-panel { 
	//Here we are going to extend properties of the class .panel 
	@extend .panel; 
	width: 150px; 
	font-size : 2em;	
}



 Now  .big-panel has the same base properties as .panel, but also  a width and font-size.
 So we use the 'extend' directive as a simple way to reuse the rules written for one element and then add more others. 

  

------------- I'll be back  |O.|Â°| ----------------------------











































